lib\main.dart：【import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'providers/chat_provider.dart';
import 'screens/chat_screen.dart';
import 'utils/theme.dart'; // Import your theme

void main() {
  // 确保 Windows 桌面支持已初始化 (如果你的 Flutter 版本需要)
  // WidgetsFlutterBinding.ensureInitialized();
  // if (Platform.isWindows) {
  //   // Windows specific setup if any
  // }
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => ChatProvider(),
      child: MaterialApp(
        title: 'Flutter Go Chat',
        theme: AppTheme.lightTheme, // 使用自定义主题
        // darkTheme: AppTheme.darkTheme, // (可选) 如果你定义了暗黑主题
        // themeMode: ThemeMode.system, // (可选) 跟随系统设置
        debugShowCheckedModeBanner: false,
        home: ChatScreen(),
      ),
    );
  }
}】
lib\models\message_model.dart：【import 'dart:convert';

// 用于和服务器交互的原始消息结构
class ServerMessage {
  final String command;
  final String data;

  ServerMessage({required this.command, required this.data});

  factory ServerMessage.fromJson(Map<String, dynamic> json) {
    return ServerMessage(
      command: json['command'] as String,
      data: json['data'] as String,
    );
  }

  static ServerMessage fromRawJson(String rawJson) {
    return ServerMessage.fromJson(jsonDecode(rawJson));
  }

  Map<String, dynamic> toJson() {
    return {'command': command, 'data': data};
  }

  stringtoRawJson() => jsonEncode(toJson());
}

// 用于在 UI 中显示的聊天消息结构
class UIMessage {
  final String id; // 唯一ID，可以是消息内容+时间戳等组合
  final String text;
  final String senderId; // "SERVER_BROADCAST" 或 "USER_LIST_UPDATE" 或实际用户ID
  final bool isMe;
  final DateTime timestamp;

  UIMessage({
    required this.text,
    required this.senderId,
    this.isMe = false,
    DateTime? timestamp,
  }) : id =
           '${senderId}_${(timestamp ?? DateTime.now()).millisecondsSinceEpoch}',
       timestamp = timestamp ?? DateTime.now();
}】
lib\providers\chat_provider.dart：【import 'dart:async';
import 'package:flutter/material.dart';
import '../models/message_model.dart';
import '../services/websocket_service.dart';

class ChatProvider with ChangeNotifier {
  final WebSocketService _webSocketService = WebSocketService();
  // StreamSubscription? _messageSubscription; // _webSocketService.messages.listen in constructor

  String _serverUrl = 'ws://localhost:8008/ws';
  String _userId = ''; // Initialize with empty or load from storage
  String? _selectedChatUserId;

  List<String> _onlineUsers = [];
  Map<String, List<UIMessage>> _chatHistories = {};
  List<String> _debugLog = [];

  bool _isConnecting = false; // New state
  String? _connectionErrorMessage;

  // Getters
  List<String> get onlineUsers => _onlineUsers;
  String? get selectedChatUserId => _selectedChatUserId;
  List<UIMessage> get currentChatMessages =>
      _chatHistories[_selectedChatUserId] ?? [];
  bool get isConnected => _webSocketService.isConnected; // Delegate to service
  bool get isConnecting => _isConnecting; // Getter for new state
  String? get connectionErrorMessage => _connectionErrorMessage;
  String get serverUrl => _serverUrl;
  String get userId => _userId;
  List<String> get debugLog => _debugLog;

  ChatProvider() {
    // Listen to messages from WebSocketService
    _webSocketService.messages.listen(_handleServerMessage);
  }

  void _addDebugLog(String message) {
    final now = DateTime.now();
    final formattedTimestamp =
        "${now.hour.toString().padLeft(2, '0')}:${now.minute.toString().padLeft(2, '0')}:${now.second.toString().padLeft(2, '0')}";
    _debugLog.insert(0, "$formattedTimestamp - $message");
    if (_debugLog.length > 100) {
      _debugLog.removeLast();
    }
    notifyListeners();
  }

  void setServerUrl(String url) {
    _serverUrl = url;
    notifyListeners();
  }

  void setUserId(String id) {
    _userId = id;
    notifyListeners();
  }

  Future<void> connect() async {
    if (_userId.isEmpty) {
      _addDebugLog("User ID cannot be empty.");
      _connectionErrorMessage = "User ID cannot be empty.";
      notifyListeners();
      return;
    }
    if (_serverUrl.isEmpty) {
      _addDebugLog("Server URL cannot be empty.");
      _connectionErrorMessage = "Server URL cannot be empty."; // Show error
      notifyListeners();
      return;
    }
    if (_isConnecting || isConnected) {
      _addDebugLog("Already connecting or connected.");
      return;
    }

    _isConnecting = true;
    _connectionErrorMessage = null;
    _addDebugLog("Attempting to connect UserID: $_userId to $_serverUrl");
    notifyListeners();

    try {
      // Use the timeout from WebSocketService connect method (default 10s)
      await _webSocketService.connect(
        _serverUrl,
        _userId,
        onDebugMessage: _addDebugLog,
      );
      // If connect completes without error, _webSocketService.isConnected should be true.
      // Actual confirmation of connection often comes with the first message (e.g., welcome or userList).
      if (_webSocketService.isConnected) {
        _addDebugLog("Connection successful (according to WebSocketService).");
      } else {
        _addDebugLog(
          "WebSocketService connect call completed, but not connected. Check logs for errors (e.g. timeout).",
        );
      }
    } catch (e) {
      _addDebugLog("Connection attempt failed in Provider: ${e.toString()}");
      // The SYSTEM message from WebSocketService should have already updated state if error occurred there.
    } finally {
      _isConnecting = false;
      // The isConnected status is now directly from _webSocketService.isConnected
      // _handleServerMessage will also call notifyListeners when messages arrive (or connection status changes)
      notifyListeners();
    }
  }

  void _handleServerMessage(ServerMessage message) {
    _addDebugLog(
      "Provider received: Command: ${message.command}, Data: ${message.data}",
    );

    // If we receive any message, it implies the "connecting" phase is over.
    // However, _isConnecting is more robustly handled in connect() method's finally block.
    // _isConnecting = false; // This might be redundant if connect() handles it well

    switch (message.command) {
      case 'userList':
        _onlineUsers = message.data
            .split(',')
            .where((id) => id.isNotEmpty && id != _userId)
            .toList();
        _addDebugLog("User list updated: $_onlineUsers");
        _connectionErrorMessage = null;

        break;
      case 'brodcastMes':
        final broadcast = UIMessage(
          text: message.data,
          senderId: 'SERVER_BROADCAST',
        );
        _addDebugLog("Broadcast message received: ${message.data}.");
        // Add to current chat or a general system log
        if (_selectedChatUserId != null) {
          _addMessageToHistory(_selectedChatUserId!, broadcast);
        }
        if (!_chatHistories.containsKey('SERVER_BROADCAST')) {
          _chatHistories['SERVER_BROADCAST'] = [];
        }
        _chatHistories['SERVER_BROADCAST']!.add(broadcast);
        break;
      case 'SYSTEM':
        _addDebugLog("System message: ${message.data}");
        if (message.data.contains("Disconnected") ||
            message.data.contains("Connection Error") ||
            message.data.contains("Connection Timeout") ||
            message.data.contains("Connection Failed")) {
          _onlineUsers = [];
          _selectedChatUserId = null;
          // _isConnecting = false; // ensure connecting state is reset on failure
          if (!message.data.contains("Disconnected manually")) {
            _connectionErrorMessage = "Connection is error, Please Check";
            // message.data; // Set error from SYSTEM message
          }
        }
        break;
      case 'PARSE_ERROR':
        _addDebugLog("Message parsing error: ${message.data}");
        break;
      default:
        final senderId = message.command;
        if (senderId == _userId) return;

        final uiMessage = UIMessage(
          text: message.data,
          senderId: senderId,
          isMe: false,
        );
        _addMessageToHistory(senderId, uiMessage);
        _addDebugLog("Message from $senderId: ${message.data}");
        break;
    }
    notifyListeners();
  }

  void _addMessageToHistory(String partnerId, UIMessage message) {
    if (!_chatHistories.containsKey(partnerId)) {
      _chatHistories[partnerId] = [];
    }
    _chatHistories[partnerId]!.add(message);
    notifyListeners(); // Notify after adding message specifically for UI update
  }

  void selectChat(String? userId) {
    _selectedChatUserId = userId;
    _addDebugLog("Selected chat with: $userId");
    notifyListeners();
  }

  void sendMessage(String text) {
    if (_selectedChatUserId == null || text.trim().isEmpty || !isConnected) {
      _addDebugLog(
        "Cannot send: No user selected, message empty, or not connected.",
      );
      return;
    }

    _webSocketService.sendMessage(_selectedChatUserId!, text.trim());

    final sentMessage = UIMessage(
      text: text.trim(),
      senderId: _userId,
      isMe: true,
    );
    _addMessageToHistory(_selectedChatUserId!, sentMessage);
    _addDebugLog("Sent to $_selectedChatUserId: $text");
    // notifyListeners(); // _addMessageToHistory calls notifyListeners
  }

  Future<void> disconnect() async {
    _addDebugLog("Disconnecting from provider...");
    await _webSocketService.disconnect(); // now async
    _onlineUsers = [];
    _selectedChatUserId = null;
    _isConnecting = false; // Ensure this is reset
    _connectionErrorMessage = null; // Clear error on manual disconnect

    // _chatHistories.clear(); // Optional
    _addDebugLog("Disconnected from provider.");
    notifyListeners();
  }

  @override
  void dispose() {
    _addDebugLog("Disposing ChatProvider...");
    // _messageSubscription?.cancel(); // Listener in constructor now
    _webSocketService.dispose();
    super.dispose();
  }
}】
lib\screens\chat_screen.dart：【import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/chat_provider.dart';
import '../widgets/user_list_tile.dart';
import '../widgets/message_bubble.dart';
import '../widgets/connection_bar.dart';

class ChatScreen extends StatefulWidget {
  const ChatScreen({Key? key}) : super(key: key);

  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController =
      ScrollController(); // For chat messages

  void _sendMessage() {
    if (_messageController.text.isNotEmpty) {
      context.read<ChatProvider>().sendMessage(_messageController.text);
      _messageController.clear();
      // Scroll to bottom after sending
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_scrollController.hasClients) {
          _scrollController.animateTo(
            _scrollController.position.maxScrollExtent,
            duration: Duration(milliseconds: 300),
            curve: Curves.easeOut,
          );
        }
      });
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Scroll to bottom when messages are updated
    final chatProvider = context.watch<ChatProvider>();
    if (chatProvider.currentChatMessages.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_scrollController.hasClients) {
          _scrollController.animateTo(
            _scrollController.position.maxScrollExtent,
            duration: Duration(milliseconds: 100), // Quicker for incoming
            curve: Curves.easeOut,
          );
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final chatProvider = context.watch<ChatProvider>();
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text('Flutter Go Chat Client'),
        actions: [
          // Optional: Button to show debug log
          IconButton(
            icon: Icon(Icons.bug_report_outlined),
            tooltip: "Show Debug Log",
            onPressed: () {
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: Text("Debug Log"),
                  content: Container(
                    width: double.maxFinite,
                    child: ListView.builder(
                      shrinkWrap: true,
                      itemCount: chatProvider.debugLog.length,
                      itemBuilder: (context, index) {
                        return Text(
                          chatProvider.debugLog[index],
                          style: TextStyle(fontSize: 10),
                        );
                      },
                    ),
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(context).pop(),
                      child: Text("Close"),
                    ),
                  ],
                ),
              );
            },
          ),
        ],
      ),
      body: Column(
        children: [
          ConnectionBar(),
          Expanded(
            child: Row(
              children: <Widget>[
                // Left Panel: User List
                Container(
                  width: 250, // Fixed width for user list
                  decoration: BoxDecoration(
                    color: theme.canvasColor, // Slightly different background
                    border: Border(
                      right: BorderSide(color: theme.dividerColor),
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Text(
                          'Online Users (${chatProvider.onlineUsers.length})',
                          style: theme.textTheme.titleLarge?.copyWith(
                            fontSize: 18,
                            color: theme.colorScheme.primary,
                          ),
                        ),
                      ),
                      Expanded(
                        child:
                            chatProvider.isConnected &&
                                chatProvider.onlineUsers.isNotEmpty
                            ? ListView.builder(
                                itemCount: chatProvider.onlineUsers.length,
                                itemBuilder: (context, index) {
                                  final userId =
                                      chatProvider.onlineUsers[index];
                                  return UserListTile(userId: userId);
                                },
                              )
                            : Center(
                                child: Text(
                                  chatProvider.isConnected
                                      ? 'No other users online'
                                      : 'Not Connected',
                                  style: theme.textTheme.bodyMedium,
                                ),
                              ),
                      ),
                    ],
                  ),
                ),

                // Right Panel: Chat Area
                Expanded(
                  child: Column(
                    children: <Widget>[
                      // Chat messages area
                      Expanded(
                        child: chatProvider.selectedChatUserId == null
                            ? Center(
                                child: Text(
                                  'Select a user to start chatting.',
                                  style: theme.textTheme.titleMedium,
                                ),
                              )
                            : Container(
                                color: theme
                                    .scaffoldBackgroundColor, // Chat background
                                padding: const EdgeInsets.all(8.0),
                                child: ListView.builder(
                                  controller: _scrollController,
                                  itemCount:
                                      chatProvider.currentChatMessages.length,
                                  itemBuilder: (context, index) {
                                    final message =
                                        chatProvider.currentChatMessages[index];
                                    return MessageBubble(message: message);
                                  },
                                ),
                              ),
                      ),
                      // Message input area
                      if (chatProvider.selectedChatUserId != null &&
                          chatProvider.isConnected)
                        Padding(
                          padding: const EdgeInsets.all(10.0),
                          child: Row(
                            children: <Widget>[
                              Expanded(
                                child: TextField(
                                  controller: _messageController,
                                  decoration: InputDecoration(
                                    hintText:
                                        'Type a message to ${chatProvider.selectedChatUserId}...',
                                    filled: true,
                                    fillColor: Colors.white,
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(20.0),
                                      borderSide: BorderSide.none,
                                    ),
                                    contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16,
                                      vertical: 10,
                                    ),
                                  ),
                                  onSubmitted: (_) => _sendMessage(),
                                ),
                              ),
                              SizedBox(width: 8),
                              ElevatedButton(
                                onPressed: _sendMessage,
                                child: Icon(Icons.send),
                                style: ElevatedButton.styleFrom(
                                  shape: CircleBorder(),
                                  padding: EdgeInsets.all(14),
                                ),
                              ),
                            ],
                          ),
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}】
lib\services\websocket_service.dart：【import 'dart:async';
import 'dart:convert';
import 'dart:io' show WebSocket;
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:web_socket_channel/io.dart';

import '../models/message_model.dart';

class WebSocketService {
  IOWebSocketChannel? _channel;
  final StreamController<ServerMessage> _messagesController =
      StreamController<ServerMessage>.broadcast();
  Function(String)? _onDebugMessage;

  StreamSubscription? _streamSubscription;
  Completer<void>? _connectionCompleter;

  bool _isConnected = false;
  bool _handshakeCompleted = false;

  Stream<ServerMessage> get messages => _messagesController.stream;
  bool get isConnected => _isConnected;

  void _debugPrint(String message) {
    _onDebugMessage?.call("[WebSocketService] $message");
  }

  Future<void> connect(
    String url,
    String userId, {
    Duration timeout = const Duration(seconds: 5),
    Function(String)? onDebugMessage,
  }) async {
    _onDebugMessage = onDebugMessage;
    _debugPrint('Attempting to connect to $url?id=$userId');

    _isConnected = false;
    _handshakeCompleted = false;
    _connectionCompleter = Completer<void>();

    try {
      // 1. 建立 TCP ➜ WebSocket 连接，并自行设置超时。
      final rawSocket = await WebSocket.connect(
        '$url?id=$userId',
      ).timeout(timeout);
      _channel = IOWebSocketChannel(rawSocket);

      // 2. 监听数据流；首次收到任何数据 ➜ 握手成功。
      _streamSubscription = _channel!.stream.listen(
        _handleData,
        onDone: _handleDone,
        onError: _handleError,
      );

      // 3. 等待握手完成或异常。
      await _connectionCompleter!.future;
    } on TimeoutException catch (_) {
      _debugPrint('Connection timed out after ${timeout.inSeconds}s');
      _messagesController.add(
        ServerMessage(command: 'SYSTEM', data: 'Connection Timeout'),
      );
      rethrow;
    } catch (e) {
      _debugPrint('Connection failed: $e');
      _messagesController.add(
        ServerMessage(command: 'SYSTEM', data: 'Connection Failed: $e'),
      );
      rethrow;
    }
  }

  void _handleData(dynamic data) {
    if (!_handshakeCompleted) {
      _handshakeCompleted = true;
      _isConnected = true;
      _debugPrint('Handshake complete.');
      if (_connectionCompleter != null && !_connectionCompleter!.isCompleted) {
        _connectionCompleter?.complete();
      }
    }

    _debugPrint('Received raw: $data');
    try {
      final serverMessage = ServerMessage.fromRawJson(data as String);
      _messagesController.add(serverMessage);
    } catch (e) {
      _debugPrint('Error parsing message: $e. Raw data: $data');
      _messagesController.add(
        ServerMessage(command: 'PARSE_ERROR', data: 'Error parsing: $data'),
      );
    }
  }

  void _handleDone() {
    _isConnected = false;
    _handshakeCompleted = false;
    _debugPrint('Connection closed by server.');
    _messagesController.add(
      ServerMessage(command: 'SYSTEM', data: 'Disconnected from server'),
    );
    if (_connectionCompleter != null && !_connectionCompleter!.isCompleted) {
      _connectionCompleter?.completeError(
        Exception(
          'Connection closed before handshake completed or during operation',
        ),
      );
    }
  }

  void _handleError(error) {
    _isConnected = false;
    _handshakeCompleted = false;
    _debugPrint('Connection error: $error');
    _messagesController.add(
      ServerMessage(command: 'SYSTEM', data: 'Connection Error: $error'),
    );
    if (_connectionCompleter != null && !_connectionCompleter!.isCompleted) {
      _connectionCompleter?.completeError(error);
    }
  }

  void sendMessage(String command, String data) {
    if (_channel != null && _isConnected) {
      final message = ServerMessage(command: command, data: data);
      _channel!.sink.add(jsonEncode(message.toJson()));
      _debugPrint('Sent: ${message.toJson()}');
    } else {
      _debugPrint('Cannot send message, not connected or channel is null.');
    }
  }

  Future<void> disconnect() async {
    _debugPrint('Disconnecting manually...');
    await _streamSubscription?.cancel();
    await _channel?.sink.close();

    _streamSubscription = null;
    _channel = null;

    _isConnected = false;
    _handshakeCompleted = false;

    // _connectionCompleter?.completeError(Exception('Disconnected manually'));

    _messagesController.add(
      ServerMessage(command: 'SYSTEM', data: 'Disconnected manually'),
    );
    _debugPrint('Disconnected manually.');
  }

  void dispose() {
    _debugPrint('Disposing WebSocketService...');
    disconnect();
    _messagesController.close();
  }
}】
lib\utils\theme.dart：【import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      brightness: Brightness.light,
      primarySwatch: Colors.teal, // 更现代感的颜色
      scaffoldBackgroundColor: Colors.grey[100],
      appBarTheme: AppBarTheme(
        backgroundColor: Colors.teal,
        elevation: 0, // 扁平化 AppBar
        iconTheme: IconThemeData(color: Colors.white),
        titleTextStyle: TextStyle(
          color: Colors.white,
          fontSize: 20,
          fontWeight: FontWeight.w500,
        ),
      ),
      listTileTheme: ListTileThemeData(
        selectedColor: Colors.teal[700],
        selectedTileColor: Colors.teal.withOpacity(0.1),
        iconColor: Colors.teal[600],
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12.0),
          borderSide: BorderSide.none,
        ),
        filled: true,
        fillColor: Colors.white,
        contentPadding: EdgeInsets.symmetric(horizontal: 16.0, vertical: 14.0),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.teal,
          foregroundColor: Colors.white,
          padding: EdgeInsets.symmetric(horizontal: 20, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12.0),
          ),
        ),
      ),
      cardTheme: CardThemeData(
        elevation: 1.0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12.0),
        ),
      ),
      colorScheme: ColorScheme.light(
        primary: Colors.teal,
        secondary: Colors.amber, // 一个强调色
        surface: Colors.white,
        background: Colors.grey[100]!,
        onPrimary: Colors.white,
        onSecondary: Colors.black,
        onSurface: Colors.black87,
        onBackground: Colors.black87,
        error: Colors.redAccent,
        onError: Colors.white,
      ),
      dividerColor: Colors.grey[300],
      textTheme: TextTheme(
        // 更现代化的字体（需要引入字体，这里使用系统默认）
        bodyLarge: TextStyle(fontSize: 16.0, color: Colors.black87),
        bodyMedium: TextStyle(fontSize: 14.0, color: Colors.black54),
        titleLarge: TextStyle(
          fontSize: 20.0,
          fontWeight: FontWeight.bold,
          color: Colors.black87,
        ),
        labelLarge: TextStyle(
          fontSize: 16.0,
          fontWeight: FontWeight.w500,
          color: Colors.white,
        ),
      ),
    );
  }

  // 如果需要暗黑主题，可以在这里添加
  // static ThemeData get darkTheme { ... }
}】
lib\widgets\connection_bar.dart：【// lib/widgets/connection_bar.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/chat_provider.dart';

class ConnectionBar extends StatefulWidget {
  const ConnectionBar({Key? key}) : super(key: key);

  @override
  _ConnectionBarState createState() => _ConnectionBarState();
}

class _ConnectionBarState extends State<ConnectionBar> {
  late TextEditingController _urlController;
  late TextEditingController _userIdController;

  @override
  void initState() {
    super.initState();
    final chatProvider = Provider.of<ChatProvider>(context, listen: false);
    _urlController = TextEditingController(text: chatProvider.serverUrl);
    _userIdController = TextEditingController(text: chatProvider.userId);
  }

  @override
  void dispose() {
    _urlController.dispose();
    _userIdController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final chatProvider = context.watch<ChatProvider>();
    final theme = Theme.of(context);
    final bool isConnected = chatProvider.isConnected;
    final bool isLoading = chatProvider.isConnecting;
    final String? connectionError =
        chatProvider.connectionErrorMessage; // Get the error message

    return Container(
      padding: const EdgeInsets.all(12.0),
      color: theme.colorScheme.surface.withOpacity(0.8),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            children: <Widget>[
              Expanded(
                flex: 3,
                child: TextField(
                  controller: _urlController,
                  enabled: !isConnected && !isLoading,
                  decoration: InputDecoration(
                    labelText: 'Server URL',
                    hintText: 'ws://localhost:8008/ws',
                    prefixIcon: Icon(Icons.link),
                  ),
                  onChanged: isLoading || isConnected
                      ? null
                      : (value) => chatProvider.setServerUrl(value),
                ),
              ),
              SizedBox(width: 10),
              Expanded(
                flex: 2,
                child: TextField(
                  controller: _userIdController,
                  enabled: !isConnected && !isLoading,
                  decoration: InputDecoration(
                    labelText: 'Your User ID',
                    hintText: 'user123',
                    prefixIcon: Icon(Icons.person_outline),
                  ),
                  onChanged: isLoading || isConnected
                      ? null
                      : (value) => chatProvider.setUserId(value),
                ),
              ),
              SizedBox(width: 10),
              ElevatedButton.icon(
                icon: Icon(
                  isLoading
                      ? Icons.hourglass_empty
                      : (isConnected ? Icons.cloud_off : Icons.cloud_queue),
                ),
                label: Text(
                  isLoading
                      ? 'Connecting...'
                      : (isConnected ? 'Disconnect' : 'Connect'),
                ),
                style: ElevatedButton.styleFrom(
                  backgroundColor: isLoading
                      ? Colors.grey
                      : (isConnected
                            ? Colors.orangeAccent
                            : theme.colorScheme.primary),
                ),
                onPressed: isLoading
                    ? null
                    : () {
                        if (isConnected) {
                          chatProvider.disconnect();
                        } else {
                          chatProvider.connect();
                        }
                      },
              ),
            ],
          ),
          // Status messages
          if (isLoading)
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(
                      strokeWidth: 2.0,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  SizedBox(width: 8),
                  Text(
                    'Attempting to connect to server...',
                    style: TextStyle(
                      color: theme.textTheme.bodyMedium?.color?.withOpacity(
                        0.7,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          if (!isLoading &&
              isConnected) // Only show if not loading AND connected [cite: 182]
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Row(
                children: [
                  Icon(Icons.check_circle, color: Colors.green, size: 18),
                  SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Connected as "${chatProvider.userId}" to ${chatProvider.serverUrl}',
                      style: TextStyle(color: Colors.green[700]),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
          // New: Display connection error message
          if (!isLoading && !isConnected && connectionError != null)
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.error_outline,
                    color: theme.colorScheme.error,
                    size: 18,
                  ),
                  SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      connectionError,
                      style: TextStyle(
                        color: theme.colorScheme.error,
                        // fontWeight: FontWeight.bold, // Optional: make it bolder
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}】
lib\widgets\message_bubble.dart：【import 'package:flutter/material.dart';
import '../models/message_model.dart';
import 'package:intl/intl.dart'; // 需要添加 intl 包: flutter pub add intl

class MessageBubble extends StatelessWidget {
  final UIMessage message;

  const MessageBubble({Key? key, required this.message}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final isMe = message.isMe;
    final isServerBroadcast = message.senderId == 'SERVER_BROADCAST';
    final theme = Theme.of(context);

    if (isServerBroadcast) {
      return Center(
        child: Container(
          margin: EdgeInsets.symmetric(vertical: 8.0),
          padding: EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0),
          decoration: BoxDecoration(
            color: Colors.blueGrey[100],
            borderRadius: BorderRadius.circular(12.0),
          ),
          child: Text(
            message.text,
            style: TextStyle(
              color: Colors.blueGrey[700],
              fontStyle: FontStyle.italic,
            ),
          ),
        ),
      );
    }

    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: Card(
        elevation: 1.5,
        color: isMe
            ? theme.colorScheme.primary.withOpacity(0.9)
            : theme.colorScheme.surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(16),
            topRight: Radius.circular(16),
            bottomLeft: isMe ? Radius.circular(16) : Radius.circular(4),
            bottomRight: isMe ? Radius.circular(4) : Radius.circular(16),
          ),
        ),
        margin: EdgeInsets.symmetric(vertical: 4, horizontal: 8),
        child: Padding(
          padding: EdgeInsets.symmetric(vertical: 10, horizontal: 14),
          child: Column(
            crossAxisAlignment: isMe
                ? CrossAxisAlignment.end
                : CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              if (!isMe)
                Text(
                  message.senderId,
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 12,
                    color: isMe ? Colors.white70 : theme.colorScheme.primary,
                  ),
                ),
              SizedBox(height: !isMe ? 4 : 0),
              Text(
                message.text,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: isMe ? Colors.white : Colors.black87,
                  fontSize: 15,
                ),
              ),
              SizedBox(height: 5),
              Text(
                DateFormat('HH:mm').format(message.timestamp),
                style: TextStyle(
                  fontSize: 10,
                  color: isMe
                      ? Colors.white.withOpacity(0.7)
                      : Colors.grey[600],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}】
lib\widgets\user_list_tile.dart：【import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/chat_provider.dart';

class UserListTile extends StatelessWidget {
  final String userId;

  const UserListTile({Key? key, required this.userId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final chatProvider = Provider.of<ChatProvider>(context, listen: false);
    final selectedUserId = context
        .watch<ChatProvider>()
        .selectedChatUserId; // Watch for changes

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: Theme.of(context).colorScheme.primary.withOpacity(0.8),
        child: Text(
          userId.isNotEmpty ? userId[0].toUpperCase() : '?',
          style: TextStyle(color: Colors.white),
        ),
      ),
      title: Text(
        userId,
        style: Theme.of(
          context,
        ).textTheme.bodyLarge?.copyWith(fontWeight: FontWeight.w500),
      ),
      selected: userId == selectedUserId,
      onTap: () {
        chatProvider.selectChat(userId);
      },
      // trailing: Badge( //  (需要 material 3 enabled 或 custom badge)
      //   label: Text('3'), // 未读消息数量
      //   isLabelVisible: true,
      // ),
    );
  }
}】
main.go:【package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"sync"

	"github.com/gorilla/websocket"
)

type Client struct {
	ID   string
	Conn *websocket.Conn
}

type Message struct {
	Command string `json:"command"` // 用于区分服务器命令或转发
	Data    string `json:"data"`    // 消息内容
}

var (
	upgrader     = websocket.Upgrader{CheckOrigin: func(r *http.Request) bool { return true }}
	clients      = make(map[string]*Client) // 存储所有连接的客户端
	clientsMutex sync.Mutex                 // 保护客户端列表的并发安全
)

func main() {
	http.HandleFunc("/ws", handleConnections)
	log.Println("启动 WebSocket 服务器，监听端口 8008...")
	log.Fatal(http.ListenAndServe(":8008", nil))
}

func handleConnections(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Println("升级为 WebSocket 失败:", err)
		return
	}
	defer conn.Close()

	// 获取用户 ID
	userID := r.URL.Query().Get("id")
	if userID == "" {
		userID = fmt.Sprintf("用户-%d", len(clients)+1)
	}

	// 将用户添加到客户端列表
	client := &Client{ID: userID, Conn: conn}
	clientsMutex.Lock()
	clients[userID] = client
	clientsMutex.Unlock()
	log.Printf("新用户连接: %s\n", userID)

	//-----------------------------------------------
	broadNormalMessage("Welcome to My Go ChatApplication", client)
	//-----------------------------------------------
	// 新加入的用户也需要广播用户列表
	broadcastUserList()
	//开一个线程来读取命令行的广播消息
	go func() {
		var broadcast string
		for {
			fmt.Printf("请输入你需要广播的内容： ")
			fmt.Scan(&broadcast)
			broadNormalMessage(broadcast, nil)
		}
	}()
	// 监听客户端消息
	OnReceiveMes(client)

	// 用户断开连接时，移除用户
	clientsMutex.Lock()
	delete(clients, userID)
	clientsMutex.Unlock()
	log.Printf("用户 %s 已断开连接\n", userID)

	// 广播更新的用户列表
	broadcastUserList()

}
func forwardToUser(sender string, targetUser string, message string) {
	clientsMutex.Lock()
	defer clientsMutex.Unlock()

	// 检查目标用户是否在线
	client, ok := clients[targetUser]
	if !ok {
		log.Printf("用户 %s 不在线，消息未发送: %s\n", targetUser, message)
		return
	}

	// 创建消息结构
	responseMessage := Message{
		Command: sender,
		Data:    message,
	}

	// 将消息转换为 JSON
	response, err := json.Marshal(responseMessage)
	if err != nil {
		log.Println("生成消息 JSON 失败:", err)
		return
	}

	// 向目标用户发送消息
	err = client.Conn.WriteMessage(websocket.TextMessage, response)
	if err != nil {
		log.Printf("向用户 %s 发送消息失败: %v\n", targetUser, err)
	} else {
		log.Printf("成功转发消息给用户 %s: %s\n", targetUser, message)
	}
}

func OnReceiveMes(client *Client) {
	// 读取客户端消息
	for {
		_, rawMessage, err := client.Conn.ReadMessage()
		if err != nil {
			log.Printf("用户断开连接: %s, 错误: %v\n", client.ID, err)
			break
		}
		log.Printf("收到来自 %s 的消息: %s\n", client.ID, string(rawMessage))
		// 解析 JSON 消息
		var msg Message
		err = json.Unmarshal(rawMessage, &msg)
		if err != nil {
			log.Printf("解析消息出错: %v\n", err)
			continue
		}
		// 根据 command 字段处理逻辑
		switch msg.Command {
		case "server":
			// 处理服务器消息
			log.Printf("处理用户发来的服务器消息: %s\n", msg.Data)
			//handleServerCommand(msg.Data)

		default:
			// 转发给其他用户
			log.Printf("转发消息给其他用户: %s\n", msg.Data)
			forwardToUser(client.ID, msg.Command, msg.Data)
		}

	}
}

func broadcastUserList() {
	clientsMutex.Lock()
	defer clientsMutex.Unlock()

	if len(clients) < 2 {
		return
	}

	for _, client := range clients {
		// 当前客户端的 ID
		excludeUser := client.ID

		// 构建用户列表，排除当前客户端
		var userList []string
		for id := range clients {
			if id != excludeUser {
				userList = append(userList, id)
			}
		}

		// 创建消息结构
		message := Message{
			Command: "userList",
			Data:    strings.Join(userList, ","), // 将用户列表转换为字符串
		}

		// 将消息转换为 JSON
		response, err := json.Marshal(message)
		if err != nil {
			log.Println("生成用户列表 JSON 失败:", err)
			continue
		}

		// 向当前客户端发送用户列表
		err = client.Conn.WriteMessage(websocket.TextMessage, response)
		if err != nil {
			log.Printf("向客户端 %s 发送用户列表失败: %v\n", client.ID, err)
		}
	}
}

func broadNormalMessage(data string, targetClient *Client) {
	clientsMutex.Lock()
	defer clientsMutex.Unlock()

	// 创建消息结构
	message := Message{
		Command: "brodcastMes",
		Data:    data,
	}

	// 将消息转换为 JSON
	response, err := json.Marshal(message)
	if err != nil {
		log.Println("生成普通消息 JSON 失败:", err)
		return
	}

	// 判断是否是广播还是单发
	if targetClient == nil {
		for _, client := range clients {
			err = client.Conn.WriteMessage(websocket.TextMessage, response)
			if err != nil {
				log.Printf("向客户端 %s 发送消息失败: %v\n", client.ID, err)
			}
		}
	} else {
		err = targetClient.Conn.WriteMessage(websocket.TextMessage, response)
		if err != nil {
			log.Printf("向客户端 %s 发送消息失败: %v\n", targetClient.ID, err)
		}
	}
}
】